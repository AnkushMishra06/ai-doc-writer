[
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\adapters.py",
    "code_entity_type": "ClassDef",
    "entity_name": "HTTPAdapter",
    "parameters": [],
    "docstring_reference": "The built-in HTTP Adapter for urllib3.\n\nProvides a general-case interface for Requests sessions to contact HTTP and\nHTTPS urls by implementing the Transport Adapter interface. This class will\nusually be created by the :class:`Session <Session>` class under the\ncovers.\n\n:param pool_connections: The number of urllib3 connection pools to cache.\n:param pool_maxsize: The maximum number of connections to save in the pool.\n:param max_retries: The maximum number of retries each connection\n    should attempt. Note, this applies only to failed DNS lookups, socket\n    connections and connection timeouts, never to requests where data has\n    made it to the server. By default, Requests does not retry failed\n    connections. If you need granular control over the conditions under\n    which we retry a request, import urllib3's ``Retry`` class and pass\n    that instead.\n:param pool_block: Whether the connection pool should block for connections.\n\nUsage::\n\n  >>> import requests\n  >>> s = requests.Session()\n  >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n  >>> s.mount('http://', a)",
    "code_block": "class HTTPAdapter(BaseAdapter):\n    \"\"\"The built-in HTTP Adapter for urllib3.\n\n    Provides a general-case interface for Requests sessions to contact HTTP and\n    HTTPS urls by implementing the Transport Adapter interface. This class will\n    usually be created by the :class:`Session <Session>` class under the\n    covers.\n\n    :param pool_connections: The number of urllib3 connection pools to cache.\n    :param pool_maxsize: The maximum number of connections to save in the pool.\n    :param max_retries: The maximum number of retries each connection\n        should attempt. Note, this applies only to failed DNS lookups, socket\n        connections and connection timeouts, never to requests where data has\n        made it to the server. By default, Requests does not retry failed\n        connections. If you need granular control over the conditions under\n        which we retry a request, import urllib3's ``Retry`` class and pass\n        that instead.\n    :param pool_block: Whether the connection pool should block for connections.\n\n    Usage::\n\n      >>> import requests\n      >>> s = requests.Session()\n      >>> a = requests.adapters.HTTPAdapter(max_retries=3)\n      >>> s.mount('http://', a)\n    \"\"\"\n    __attrs__ = ['max_retries', 'config', '_pool_connections', '_pool_maxsize', '_pool_block']\n\n    def __init__(self, pool_connections=DEFAULT_POOLSIZE, pool_maxsize=DEFAULT_POOLSIZE, max_retries=DEFAULT_RETRIES, pool_block=DEFAULT_POOLBLOCK):\n        if max_retries == DEFAULT_RETRIES:\n            self.max_retries = Retry(0, read=False)\n        else:\n            self.max_retries = Retry.from_int(max_retries)\n        self.config = {}\n        self.proxy_manager = {}\n        super().__init__()\n        self._pool_connections = pool_connections\n        self._pool_maxsize = pool_maxsize\n        self._pool_block = pool_block\n        self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)\n\n    def __getstate__(self):\n        return {attr: getattr(self, attr, None) for attr in self.__attrs__}\n\n    def __setstate__(self, state):\n        self.proxy_manager = {}\n        self.config = {}\n        for attr, value in state.items():\n            setattr(self, attr, value)\n        self.init_poolmanager(self._pool_connections, self._pool_maxsize, block=self._pool_block)\n\n    def init_poolmanager(self, connections, maxsize, block=DEFAULT_POOLBLOCK, **pool_kwargs):\n        \"\"\"Initializes a urllib3 PoolManager.\n\n        This method should not be called from user code, and is only\n        exposed for use when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param connections: The number of urllib3 connection pools to cache.\n        :param maxsize: The maximum number of connections to save in the pool.\n        :param block: Block when no free connections are available.\n        :param pool_kwargs: Extra keyword arguments used to initialize the Pool Manager.\n        \"\"\"\n        self._pool_connections = connections\n        self._pool_maxsize = maxsize\n        self._pool_block = block\n        self.poolmanager = PoolManager(num_pools=connections, maxsize=maxsize, block=block, **pool_kwargs)\n\n    def proxy_manager_for(self, proxy, **proxy_kwargs):\n        \"\"\"Return urllib3 ProxyManager for the given proxy.\n\n        This method should not be called from user code, and is only\n        exposed for use when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param proxy: The proxy to return a urllib3 ProxyManager for.\n        :param proxy_kwargs: Extra keyword arguments used to configure the Proxy Manager.\n        :returns: ProxyManager\n        :rtype: urllib3.ProxyManager\n        \"\"\"\n        if proxy in self.proxy_manager:\n            manager = self.proxy_manager[proxy]\n        elif proxy.lower().startswith('socks'):\n            username, password = get_auth_from_url(proxy)\n            manager = self.proxy_manager[proxy] = SOCKSProxyManager(proxy, username=username, password=password, num_pools=self._pool_connections, maxsize=self._pool_maxsize, block=self._pool_block, **proxy_kwargs)\n        else:\n            proxy_headers = self.proxy_headers(proxy)\n            manager = self.proxy_manager[proxy] = proxy_from_url(proxy, proxy_headers=proxy_headers, num_pools=self._pool_connections, maxsize=self._pool_maxsize, block=self._pool_block, **proxy_kwargs)\n        return manager\n\n    def cert_verify(self, conn, url, verify, cert):\n        \"\"\"Verify a SSL certificate. This method should not be called from user\n        code, and is only exposed for use when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param conn: The urllib3 connection object associated with the cert.\n        :param url: The requested URL.\n        :param verify: Either a boolean, in which case it controls whether we verify\n            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use\n        :param cert: The SSL certificate to verify.\n        \"\"\"\n        if url.lower().startswith('https') and verify:\n            cert_loc = None\n            if verify is not True:\n                cert_loc = verify\n            if not cert_loc:\n                cert_loc = extract_zipped_paths(DEFAULT_CA_BUNDLE_PATH)\n            if not cert_loc or not os.path.exists(cert_loc):\n                raise OSError(f'Could not find a suitable TLS CA certificate bundle, invalid path: {cert_loc}')\n            conn.cert_reqs = 'CERT_REQUIRED'\n            if not os.path.isdir(cert_loc):\n                conn.ca_certs = cert_loc\n            else:\n                conn.ca_cert_dir = cert_loc\n        else:\n            conn.cert_reqs = 'CERT_NONE'\n            conn.ca_certs = None\n            conn.ca_cert_dir = None\n        if cert:\n            if not isinstance(cert, basestring):\n                conn.cert_file = cert[0]\n                conn.key_file = cert[1]\n            else:\n                conn.cert_file = cert\n                conn.key_file = None\n            if conn.cert_file and (not os.path.exists(conn.cert_file)):\n                raise OSError(f'Could not find the TLS certificate file, invalid path: {conn.cert_file}')\n            if conn.key_file and (not os.path.exists(conn.key_file)):\n                raise OSError(f'Could not find the TLS key file, invalid path: {conn.key_file}')\n\n    def build_response(self, req, resp):\n        \"\"\"Builds a :class:`Response <requests.Response>` object from a urllib3\n        response. This should not be called from user code, and is only exposed\n        for use when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`\n\n        :param req: The :class:`PreparedRequest <PreparedRequest>` used to generate the response.\n        :param resp: The urllib3 response object.\n        :rtype: requests.Response\n        \"\"\"\n        response = Response()\n        response.status_code = getattr(resp, 'status', None)\n        response.headers = CaseInsensitiveDict(getattr(resp, 'headers', {}))\n        response.encoding = get_encoding_from_headers(response.headers)\n        response.raw = resp\n        response.reason = response.raw.reason\n        if isinstance(req.url, bytes):\n            response.url = req.url.decode('utf-8')\n        else:\n            response.url = req.url\n        extract_cookies_to_jar(response.cookies, req, resp)\n        response.request = req\n        response.connection = self\n        return response\n\n    def build_connection_pool_key_attributes(self, request, verify, cert=None):\n        \"\"\"Build the PoolKey attributes used by urllib3 to return a connection.\n\n        This looks at the PreparedRequest, the user-specified verify value,\n        and the value of the cert parameter to determine what PoolKey values\n        to use to select a connection from a given urllib3 Connection Pool.\n\n        The SSL related pool key arguments are not consistently set. As of\n        this writing, use the following to determine what keys may be in that\n        dictionary:\n\n        * If ``verify`` is ``True``, ``\"ssl_context\"`` will be set and will be the\n          default Requests SSL Context\n        * If ``verify`` is ``False``, ``\"ssl_context\"`` will not be set but\n          ``\"cert_reqs\"`` will be set\n        * If ``verify`` is a string, (i.e., it is a user-specified trust bundle)\n          ``\"ca_certs\"`` will be set if the string is not a directory recognized\n          by :py:func:`os.path.isdir`, otherwise ``\"ca_cert_dir\"`` will be\n          set.\n        * If ``\"cert\"`` is specified, ``\"cert_file\"`` will always be set. If\n          ``\"cert\"`` is a tuple with a second item, ``\"key_file\"`` will also\n          be present\n\n        To override these settings, one may subclass this class, call this\n        method and use the above logic to change parameters as desired. For\n        example, if one wishes to use a custom :py:class:`ssl.SSLContext` one\n        must both set ``\"ssl_context\"`` and based on what else they require,\n        alter the other keys to ensure the desired behaviour.\n\n        :param request:\n            The PreparedReqest being sent over the connection.\n        :type request:\n            :class:`~requests.models.PreparedRequest`\n        :param verify:\n            Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use.\n        :param cert:\n            (optional) Any user-provided SSL certificate for client\n            authentication (a.k.a., mTLS). This may be a string (i.e., just\n            the path to a file which holds both certificate and key) or a\n            tuple of length 2 with the certificate file path and key file\n            path.\n        :returns:\n            A tuple of two dictionaries. The first is the \"host parameters\"\n            portion of the Pool Key including scheme, hostname, and port. The\n            second is a dictionary of SSLContext related parameters.\n        \"\"\"\n        return _urllib3_request_context(request, verify, cert, self.poolmanager)\n\n    def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):\n        \"\"\"Returns a urllib3 connection for the given request and TLS settings.\n        This should not be called from user code, and is only exposed for use\n        when subclassing the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param request:\n            The :class:`PreparedRequest <PreparedRequest>` object to be sent\n            over the connection.\n        :param verify:\n            Either a boolean, in which case it controls whether we verify the\n            server's TLS certificate, or a string, in which case it must be a\n            path to a CA bundle to use.\n        :param proxies:\n            (optional) The proxies dictionary to apply to the request.\n        :param cert:\n            (optional) Any user-provided SSL certificate to be used for client\n            authentication (a.k.a., mTLS).\n        :rtype:\n            urllib3.ConnectionPool\n        \"\"\"\n        proxy = select_proxy(request.url, proxies)\n        try:\n            host_params, pool_kwargs = self.build_connection_pool_key_attributes(request, verify, cert)\n        except ValueError as e:\n            raise InvalidURL(e, request=request)\n        if proxy:\n            proxy = prepend_scheme_if_needed(proxy, 'http')\n            proxy_url = parse_url(proxy)\n            if not proxy_url.host:\n                raise InvalidProxyURL('Please check proxy URL. It is malformed and could be missing the host.')\n            proxy_manager = self.proxy_manager_for(proxy)\n            conn = proxy_manager.connection_from_host(**host_params, pool_kwargs=pool_kwargs)\n        else:\n            conn = self.poolmanager.connection_from_host(**host_params, pool_kwargs=pool_kwargs)\n        return conn\n\n    def get_connection(self, url, proxies=None):\n        \"\"\"DEPRECATED: Users should move to `get_connection_with_tls_context`\n        for all subclasses of HTTPAdapter using Requests>=2.32.2.\n\n        Returns a urllib3 connection for the given URL. This should not be\n        called from user code, and is only exposed for use when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param url: The URL to connect to.\n        :param proxies: (optional) A Requests-style dictionary of proxies used on this request.\n        :rtype: urllib3.ConnectionPool\n        \"\"\"\n        warnings.warn('`get_connection` has been deprecated in favor of `get_connection_with_tls_context`. Custom HTTPAdapter subclasses will need to migrate for Requests>=2.32.2. Please see https://github.com/psf/requests/pull/6710 for more details.', DeprecationWarning)\n        proxy = select_proxy(url, proxies)\n        if proxy:\n            proxy = prepend_scheme_if_needed(proxy, 'http')\n            proxy_url = parse_url(proxy)\n            if not proxy_url.host:\n                raise InvalidProxyURL('Please check proxy URL. It is malformed and could be missing the host.')\n            proxy_manager = self.proxy_manager_for(proxy)\n            conn = proxy_manager.connection_from_url(url)\n        else:\n            parsed = urlparse(url)\n            url = parsed.geturl()\n            conn = self.poolmanager.connection_from_url(url)\n        return conn\n\n    def close(self):\n        \"\"\"Disposes of any internal state.\n\n        Currently, this closes the PoolManager and any active ProxyManager,\n        which closes any pooled connections.\n        \"\"\"\n        self.poolmanager.clear()\n        for proxy in self.proxy_manager.values():\n            proxy.clear()\n\n    def request_url(self, request, proxies):\n        \"\"\"Obtain the url to use when making the final request.\n\n        If the message is being sent through a HTTP proxy, the full URL has to\n        be used. Otherwise, we should only use the path portion of the URL.\n\n        This should not be called from user code, and is only exposed for use\n        when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs.\n        :rtype: str\n        \"\"\"\n        proxy = select_proxy(request.url, proxies)\n        scheme = urlparse(request.url).scheme\n        is_proxied_http_request = proxy and scheme != 'https'\n        using_socks_proxy = False\n        if proxy:\n            proxy_scheme = urlparse(proxy).scheme.lower()\n            using_socks_proxy = proxy_scheme.startswith('socks')\n        url = request.path_url\n        if url.startswith('//'):\n            url = f\"/{url.lstrip('/')}\"\n        if is_proxied_http_request and (not using_socks_proxy):\n            url = urldefragauth(request.url)\n        return url\n\n    def add_headers(self, request, **kwargs):\n        \"\"\"Add any headers needed by the connection. As of v2.0 this does\n        nothing by default, but is left for overriding by users that subclass\n        the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        This should not be called from user code, and is only exposed for use\n        when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param request: The :class:`PreparedRequest <PreparedRequest>` to add headers to.\n        :param kwargs: The keyword arguments from the call to send().\n        \"\"\"\n        pass\n\n    def proxy_headers(self, proxy):\n        \"\"\"Returns a dictionary of the headers to add to any request sent\n        through a proxy. This works with urllib3 magic to ensure that they are\n        correctly sent to the proxy, rather than in a tunnelled request if\n        CONNECT is being used.\n\n        This should not be called from user code, and is only exposed for use\n        when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param proxy: The url of the proxy being used for this request.\n        :rtype: dict\n        \"\"\"\n        headers = {}\n        username, password = get_auth_from_url(proxy)\n        if username:\n            headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n        return headers\n\n    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n\n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n        try:\n            conn = self.get_connection_with_tls_context(request, verify, proxies=proxies, cert=cert)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\n        chunked = not (request.body is None or 'Content-Length' in request.headers)\n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(f'Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, or a single float to set both timeouts to the same value.')\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n        try:\n            resp = conn.urlopen(method=request.method, url=url, body=request.body, headers=request.headers, redirect=False, assert_same_host=False, preload_content=False, decode_content=False, retries=self.max_retries, timeout=timeout, chunked=chunked)\n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n            if isinstance(e.reason, ResponseError):\n                raise RetryError(e, request=request)\n            if isinstance(e.reason, _ProxyError):\n                raise ProxyError(e, request=request)\n            if isinstance(e.reason, _SSLError):\n                raise SSLError(e, request=request)\n            raise ConnectionError(e, request=request)\n        except ClosedPoolError as e:\n            raise ConnectionError(e, request=request)\n        except _ProxyError as e:\n            raise ProxyError(e)\n        except (_SSLError, _HTTPError) as e:\n            if isinstance(e, _SSLError):\n                raise SSLError(e, request=request)\n            elif isinstance(e, ReadTimeoutError):\n                raise ReadTimeout(e, request=request)\n            elif isinstance(e, _InvalidHeader):\n                raise InvalidHeader(e, request=request)\n            else:\n                raise\n        return self.build_response(request, resp)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\adapters.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "send",
    "parameters": [
      "self",
      "request",
      "stream",
      "timeout",
      "verify",
      "cert",
      "proxies"
    ],
    "docstring_reference": "Sends PreparedRequest object. Returns Response object.\n\n:param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n:param stream: (optional) Whether to stream the request content.\n:param timeout: (optional) How long to wait for the server to send\n    data before giving up, as a float, or a :ref:`(connect timeout,\n    read timeout) <timeouts>` tuple.\n:type timeout: float or tuple\n:param verify: (optional) Either a boolean, in which case it controls whether we verify\n    the server's TLS certificate, or a string, in which case it must be a path\n    to a CA bundle to use\n:param cert: (optional) Any user-provided SSL certificate to be trusted.\n:param proxies: (optional) The proxies dictionary to apply to the request.",
    "code_block": "def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n    \"\"\"Sends PreparedRequest object. Returns Response object.\n\n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple\n        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        \"\"\"\n    raise NotImplementedError"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\adapters.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "close",
    "parameters": [
      "self"
    ],
    "docstring_reference": "Cleans up adapter specific items.",
    "code_block": "def close(self):\n    \"\"\"Cleans up adapter specific items.\"\"\"\n    raise NotImplementedError"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\adapters.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "init_poolmanager",
    "parameters": [
      "self",
      "connections",
      "maxsize",
      "block"
    ],
    "docstring_reference": "Initializes a urllib3 PoolManager.\n\nThis method should not be called from user code, and is only\nexposed for use when subclassing the\n:class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n:param connections: The number of urllib3 connection pools to cache.\n:param maxsize: The maximum number of connections to save in the pool.\n:param block: Block when no free connections are available.\n:param pool_kwargs: Extra keyword arguments used to initialize the Pool Manager.",
    "code_block": "def init_poolmanager(self, connections, maxsize, block=DEFAULT_POOLBLOCK, **pool_kwargs):\n    \"\"\"Initializes a urllib3 PoolManager.\n\n        This method should not be called from user code, and is only\n        exposed for use when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param connections: The number of urllib3 connection pools to cache.\n        :param maxsize: The maximum number of connections to save in the pool.\n        :param block: Block when no free connections are available.\n        :param pool_kwargs: Extra keyword arguments used to initialize the Pool Manager.\n        \"\"\"\n    self._pool_connections = connections\n    self._pool_maxsize = maxsize\n    self._pool_block = block\n    self.poolmanager = PoolManager(num_pools=connections, maxsize=maxsize, block=block, **pool_kwargs)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\adapters.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "proxy_manager_for",
    "parameters": [
      "self",
      "proxy"
    ],
    "docstring_reference": "Return urllib3 ProxyManager for the given proxy.\n\nThis method should not be called from user code, and is only\nexposed for use when subclassing the\n:class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n:param proxy: The proxy to return a urllib3 ProxyManager for.\n:param proxy_kwargs: Extra keyword arguments used to configure the Proxy Manager.\n:returns: ProxyManager\n:rtype: urllib3.ProxyManager",
    "code_block": "def proxy_manager_for(self, proxy, **proxy_kwargs):\n    \"\"\"Return urllib3 ProxyManager for the given proxy.\n\n        This method should not be called from user code, and is only\n        exposed for use when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param proxy: The proxy to return a urllib3 ProxyManager for.\n        :param proxy_kwargs: Extra keyword arguments used to configure the Proxy Manager.\n        :returns: ProxyManager\n        :rtype: urllib3.ProxyManager\n        \"\"\"\n    if proxy in self.proxy_manager:\n        manager = self.proxy_manager[proxy]\n    elif proxy.lower().startswith('socks'):\n        username, password = get_auth_from_url(proxy)\n        manager = self.proxy_manager[proxy] = SOCKSProxyManager(proxy, username=username, password=password, num_pools=self._pool_connections, maxsize=self._pool_maxsize, block=self._pool_block, **proxy_kwargs)\n    else:\n        proxy_headers = self.proxy_headers(proxy)\n        manager = self.proxy_manager[proxy] = proxy_from_url(proxy, proxy_headers=proxy_headers, num_pools=self._pool_connections, maxsize=self._pool_maxsize, block=self._pool_block, **proxy_kwargs)\n    return manager"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\adapters.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "cert_verify",
    "parameters": [
      "self",
      "conn",
      "url",
      "verify",
      "cert"
    ],
    "docstring_reference": "Verify a SSL certificate. This method should not be called from user\ncode, and is only exposed for use when subclassing the\n:class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n:param conn: The urllib3 connection object associated with the cert.\n:param url: The requested URL.\n:param verify: Either a boolean, in which case it controls whether we verify\n    the server's TLS certificate, or a string, in which case it must be a path\n    to a CA bundle to use\n:param cert: The SSL certificate to verify.",
    "code_block": "def cert_verify(self, conn, url, verify, cert):\n    \"\"\"Verify a SSL certificate. This method should not be called from user\n        code, and is only exposed for use when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param conn: The urllib3 connection object associated with the cert.\n        :param url: The requested URL.\n        :param verify: Either a boolean, in which case it controls whether we verify\n            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use\n        :param cert: The SSL certificate to verify.\n        \"\"\"\n    if url.lower().startswith('https') and verify:\n        cert_loc = None\n        if verify is not True:\n            cert_loc = verify\n        if not cert_loc:\n            cert_loc = extract_zipped_paths(DEFAULT_CA_BUNDLE_PATH)\n        if not cert_loc or not os.path.exists(cert_loc):\n            raise OSError(f'Could not find a suitable TLS CA certificate bundle, invalid path: {cert_loc}')\n        conn.cert_reqs = 'CERT_REQUIRED'\n        if not os.path.isdir(cert_loc):\n            conn.ca_certs = cert_loc\n        else:\n            conn.ca_cert_dir = cert_loc\n    else:\n        conn.cert_reqs = 'CERT_NONE'\n        conn.ca_certs = None\n        conn.ca_cert_dir = None\n    if cert:\n        if not isinstance(cert, basestring):\n            conn.cert_file = cert[0]\n            conn.key_file = cert[1]\n        else:\n            conn.cert_file = cert\n            conn.key_file = None\n        if conn.cert_file and (not os.path.exists(conn.cert_file)):\n            raise OSError(f'Could not find the TLS certificate file, invalid path: {conn.cert_file}')\n        if conn.key_file and (not os.path.exists(conn.key_file)):\n            raise OSError(f'Could not find the TLS key file, invalid path: {conn.key_file}')"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\adapters.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "build_response",
    "parameters": [
      "self",
      "req",
      "resp"
    ],
    "docstring_reference": "Builds a :class:`Response <requests.Response>` object from a urllib3\nresponse. This should not be called from user code, and is only exposed\nfor use when subclassing the\n:class:`HTTPAdapter <requests.adapters.HTTPAdapter>`\n\n:param req: The :class:`PreparedRequest <PreparedRequest>` used to generate the response.\n:param resp: The urllib3 response object.\n:rtype: requests.Response",
    "code_block": "def build_response(self, req, resp):\n    \"\"\"Builds a :class:`Response <requests.Response>` object from a urllib3\n        response. This should not be called from user code, and is only exposed\n        for use when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`\n\n        :param req: The :class:`PreparedRequest <PreparedRequest>` used to generate the response.\n        :param resp: The urllib3 response object.\n        :rtype: requests.Response\n        \"\"\"\n    response = Response()\n    response.status_code = getattr(resp, 'status', None)\n    response.headers = CaseInsensitiveDict(getattr(resp, 'headers', {}))\n    response.encoding = get_encoding_from_headers(response.headers)\n    response.raw = resp\n    response.reason = response.raw.reason\n    if isinstance(req.url, bytes):\n        response.url = req.url.decode('utf-8')\n    else:\n        response.url = req.url\n    extract_cookies_to_jar(response.cookies, req, resp)\n    response.request = req\n    response.connection = self\n    return response"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\adapters.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "build_connection_pool_key_attributes",
    "parameters": [
      "self",
      "request",
      "verify",
      "cert"
    ],
    "docstring_reference": "Build the PoolKey attributes used by urllib3 to return a connection.\n\nThis looks at the PreparedRequest, the user-specified verify value,\nand the value of the cert parameter to determine what PoolKey values\nto use to select a connection from a given urllib3 Connection Pool.\n\nThe SSL related pool key arguments are not consistently set. As of\nthis writing, use the following to determine what keys may be in that\ndictionary:\n\n* If ``verify`` is ``True``, ``\"ssl_context\"`` will be set and will be the\n  default Requests SSL Context\n* If ``verify`` is ``False``, ``\"ssl_context\"`` will not be set but\n  ``\"cert_reqs\"`` will be set\n* If ``verify`` is a string, (i.e., it is a user-specified trust bundle)\n  ``\"ca_certs\"`` will be set if the string is not a directory recognized\n  by :py:func:`os.path.isdir`, otherwise ``\"ca_cert_dir\"`` will be\n  set.\n* If ``\"cert\"`` is specified, ``\"cert_file\"`` will always be set. If\n  ``\"cert\"`` is a tuple with a second item, ``\"key_file\"`` will also\n  be present\n\nTo override these settings, one may subclass this class, call this\nmethod and use the above logic to change parameters as desired. For\nexample, if one wishes to use a custom :py:class:`ssl.SSLContext` one\nmust both set ``\"ssl_context\"`` and based on what else they require,\nalter the other keys to ensure the desired behaviour.\n\n:param request:\n    The PreparedReqest being sent over the connection.\n:type request:\n    :class:`~requests.models.PreparedRequest`\n:param verify:\n    Either a boolean, in which case it controls whether\n    we verify the server's TLS certificate, or a string, in which case it\n    must be a path to a CA bundle to use.\n:param cert:\n    (optional) Any user-provided SSL certificate for client\n    authentication (a.k.a., mTLS). This may be a string (i.e., just\n    the path to a file which holds both certificate and key) or a\n    tuple of length 2 with the certificate file path and key file\n    path.\n:returns:\n    A tuple of two dictionaries. The first is the \"host parameters\"\n    portion of the Pool Key including scheme, hostname, and port. The\n    second is a dictionary of SSLContext related parameters.",
    "code_block": "def build_connection_pool_key_attributes(self, request, verify, cert=None):\n    \"\"\"Build the PoolKey attributes used by urllib3 to return a connection.\n\n        This looks at the PreparedRequest, the user-specified verify value,\n        and the value of the cert parameter to determine what PoolKey values\n        to use to select a connection from a given urllib3 Connection Pool.\n\n        The SSL related pool key arguments are not consistently set. As of\n        this writing, use the following to determine what keys may be in that\n        dictionary:\n\n        * If ``verify`` is ``True``, ``\"ssl_context\"`` will be set and will be the\n          default Requests SSL Context\n        * If ``verify`` is ``False``, ``\"ssl_context\"`` will not be set but\n          ``\"cert_reqs\"`` will be set\n        * If ``verify`` is a string, (i.e., it is a user-specified trust bundle)\n          ``\"ca_certs\"`` will be set if the string is not a directory recognized\n          by :py:func:`os.path.isdir`, otherwise ``\"ca_cert_dir\"`` will be\n          set.\n        * If ``\"cert\"`` is specified, ``\"cert_file\"`` will always be set. If\n          ``\"cert\"`` is a tuple with a second item, ``\"key_file\"`` will also\n          be present\n\n        To override these settings, one may subclass this class, call this\n        method and use the above logic to change parameters as desired. For\n        example, if one wishes to use a custom :py:class:`ssl.SSLContext` one\n        must both set ``\"ssl_context\"`` and based on what else they require,\n        alter the other keys to ensure the desired behaviour.\n\n        :param request:\n            The PreparedReqest being sent over the connection.\n        :type request:\n            :class:`~requests.models.PreparedRequest`\n        :param verify:\n            Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use.\n        :param cert:\n            (optional) Any user-provided SSL certificate for client\n            authentication (a.k.a., mTLS). This may be a string (i.e., just\n            the path to a file which holds both certificate and key) or a\n            tuple of length 2 with the certificate file path and key file\n            path.\n        :returns:\n            A tuple of two dictionaries. The first is the \"host parameters\"\n            portion of the Pool Key including scheme, hostname, and port. The\n            second is a dictionary of SSLContext related parameters.\n        \"\"\"\n    return _urllib3_request_context(request, verify, cert, self.poolmanager)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\adapters.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "get_connection_with_tls_context",
    "parameters": [
      "self",
      "request",
      "verify",
      "proxies",
      "cert"
    ],
    "docstring_reference": "Returns a urllib3 connection for the given request and TLS settings.\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n:param request:\n    The :class:`PreparedRequest <PreparedRequest>` object to be sent\n    over the connection.\n:param verify:\n    Either a boolean, in which case it controls whether we verify the\n    server's TLS certificate, or a string, in which case it must be a\n    path to a CA bundle to use.\n:param proxies:\n    (optional) The proxies dictionary to apply to the request.\n:param cert:\n    (optional) Any user-provided SSL certificate to be used for client\n    authentication (a.k.a., mTLS).\n:rtype:\n    urllib3.ConnectionPool",
    "code_block": "def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):\n    \"\"\"Returns a urllib3 connection for the given request and TLS settings.\n        This should not be called from user code, and is only exposed for use\n        when subclassing the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param request:\n            The :class:`PreparedRequest <PreparedRequest>` object to be sent\n            over the connection.\n        :param verify:\n            Either a boolean, in which case it controls whether we verify the\n            server's TLS certificate, or a string, in which case it must be a\n            path to a CA bundle to use.\n        :param proxies:\n            (optional) The proxies dictionary to apply to the request.\n        :param cert:\n            (optional) Any user-provided SSL certificate to be used for client\n            authentication (a.k.a., mTLS).\n        :rtype:\n            urllib3.ConnectionPool\n        \"\"\"\n    proxy = select_proxy(request.url, proxies)\n    try:\n        host_params, pool_kwargs = self.build_connection_pool_key_attributes(request, verify, cert)\n    except ValueError as e:\n        raise InvalidURL(e, request=request)\n    if proxy:\n        proxy = prepend_scheme_if_needed(proxy, 'http')\n        proxy_url = parse_url(proxy)\n        if not proxy_url.host:\n            raise InvalidProxyURL('Please check proxy URL. It is malformed and could be missing the host.')\n        proxy_manager = self.proxy_manager_for(proxy)\n        conn = proxy_manager.connection_from_host(**host_params, pool_kwargs=pool_kwargs)\n    else:\n        conn = self.poolmanager.connection_from_host(**host_params, pool_kwargs=pool_kwargs)\n    return conn"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\adapters.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "get_connection",
    "parameters": [
      "self",
      "url",
      "proxies"
    ],
    "docstring_reference": "DEPRECATED: Users should move to `get_connection_with_tls_context`\nfor all subclasses of HTTPAdapter using Requests>=2.32.2.\n\nReturns a urllib3 connection for the given URL. This should not be\ncalled from user code, and is only exposed for use when subclassing the\n:class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n:param url: The URL to connect to.\n:param proxies: (optional) A Requests-style dictionary of proxies used on this request.\n:rtype: urllib3.ConnectionPool",
    "code_block": "def get_connection(self, url, proxies=None):\n    \"\"\"DEPRECATED: Users should move to `get_connection_with_tls_context`\n        for all subclasses of HTTPAdapter using Requests>=2.32.2.\n\n        Returns a urllib3 connection for the given URL. This should not be\n        called from user code, and is only exposed for use when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param url: The URL to connect to.\n        :param proxies: (optional) A Requests-style dictionary of proxies used on this request.\n        :rtype: urllib3.ConnectionPool\n        \"\"\"\n    warnings.warn('`get_connection` has been deprecated in favor of `get_connection_with_tls_context`. Custom HTTPAdapter subclasses will need to migrate for Requests>=2.32.2. Please see https://github.com/psf/requests/pull/6710 for more details.', DeprecationWarning)\n    proxy = select_proxy(url, proxies)\n    if proxy:\n        proxy = prepend_scheme_if_needed(proxy, 'http')\n        proxy_url = parse_url(proxy)\n        if not proxy_url.host:\n            raise InvalidProxyURL('Please check proxy URL. It is malformed and could be missing the host.')\n        proxy_manager = self.proxy_manager_for(proxy)\n        conn = proxy_manager.connection_from_url(url)\n    else:\n        parsed = urlparse(url)\n        url = parsed.geturl()\n        conn = self.poolmanager.connection_from_url(url)\n    return conn"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\adapters.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "close",
    "parameters": [
      "self"
    ],
    "docstring_reference": "Disposes of any internal state.\n\nCurrently, this closes the PoolManager and any active ProxyManager,\nwhich closes any pooled connections.",
    "code_block": "def close(self):\n    \"\"\"Disposes of any internal state.\n\n        Currently, this closes the PoolManager and any active ProxyManager,\n        which closes any pooled connections.\n        \"\"\"\n    self.poolmanager.clear()\n    for proxy in self.proxy_manager.values():\n        proxy.clear()"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\adapters.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "request_url",
    "parameters": [
      "self",
      "request",
      "proxies"
    ],
    "docstring_reference": "Obtain the url to use when making the final request.\n\nIf the message is being sent through a HTTP proxy, the full URL has to\nbe used. Otherwise, we should only use the path portion of the URL.\n\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the\n:class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n:param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n:param proxies: A dictionary of schemes or schemes and hosts to proxy URLs.\n:rtype: str",
    "code_block": "def request_url(self, request, proxies):\n    \"\"\"Obtain the url to use when making the final request.\n\n        If the message is being sent through a HTTP proxy, the full URL has to\n        be used. Otherwise, we should only use the path portion of the URL.\n\n        This should not be called from user code, and is only exposed for use\n        when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs.\n        :rtype: str\n        \"\"\"\n    proxy = select_proxy(request.url, proxies)\n    scheme = urlparse(request.url).scheme\n    is_proxied_http_request = proxy and scheme != 'https'\n    using_socks_proxy = False\n    if proxy:\n        proxy_scheme = urlparse(proxy).scheme.lower()\n        using_socks_proxy = proxy_scheme.startswith('socks')\n    url = request.path_url\n    if url.startswith('//'):\n        url = f\"/{url.lstrip('/')}\"\n    if is_proxied_http_request and (not using_socks_proxy):\n        url = urldefragauth(request.url)\n    return url"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\adapters.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "add_headers",
    "parameters": [
      "self",
      "request"
    ],
    "docstring_reference": "Add any headers needed by the connection. As of v2.0 this does\nnothing by default, but is left for overriding by users that subclass\nthe :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the\n:class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n:param request: The :class:`PreparedRequest <PreparedRequest>` to add headers to.\n:param kwargs: The keyword arguments from the call to send().",
    "code_block": "def add_headers(self, request, **kwargs):\n    \"\"\"Add any headers needed by the connection. As of v2.0 this does\n        nothing by default, but is left for overriding by users that subclass\n        the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        This should not be called from user code, and is only exposed for use\n        when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param request: The :class:`PreparedRequest <PreparedRequest>` to add headers to.\n        :param kwargs: The keyword arguments from the call to send().\n        \"\"\"\n    pass"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\adapters.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "proxy_headers",
    "parameters": [
      "self",
      "proxy"
    ],
    "docstring_reference": "Returns a dictionary of the headers to add to any request sent\nthrough a proxy. This works with urllib3 magic to ensure that they are\ncorrectly sent to the proxy, rather than in a tunnelled request if\nCONNECT is being used.\n\nThis should not be called from user code, and is only exposed for use\nwhen subclassing the\n:class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n:param proxy: The url of the proxy being used for this request.\n:rtype: dict",
    "code_block": "def proxy_headers(self, proxy):\n    \"\"\"Returns a dictionary of the headers to add to any request sent\n        through a proxy. This works with urllib3 magic to ensure that they are\n        correctly sent to the proxy, rather than in a tunnelled request if\n        CONNECT is being used.\n\n        This should not be called from user code, and is only exposed for use\n        when subclassing the\n        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n\n        :param proxy: The url of the proxy being used for this request.\n        :rtype: dict\n        \"\"\"\n    headers = {}\n    username, password = get_auth_from_url(proxy)\n    if username:\n        headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n    return headers"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\adapters.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "send",
    "parameters": [
      "self",
      "request",
      "stream",
      "timeout",
      "verify",
      "cert",
      "proxies"
    ],
    "docstring_reference": "Sends PreparedRequest object. Returns Response object.\n\n:param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n:param stream: (optional) Whether to stream the request content.\n:param timeout: (optional) How long to wait for the server to send\n    data before giving up, as a float, or a :ref:`(connect timeout,\n    read timeout) <timeouts>` tuple.\n:type timeout: float or tuple or urllib3 Timeout object\n:param verify: (optional) Either a boolean, in which case it controls whether\n    we verify the server's TLS certificate, or a string, in which case it\n    must be a path to a CA bundle to use\n:param cert: (optional) Any user-provided SSL certificate to be trusted.\n:param proxies: (optional) The proxies dictionary to apply to the request.\n:rtype: requests.Response",
    "code_block": "def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n    \"\"\"Sends PreparedRequest object. Returns Response object.\n\n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    try:\n        conn = self.get_connection_with_tls_context(request, verify, proxies=proxies, cert=cert)\n    except LocationValueError as e:\n        raise InvalidURL(e, request=request)\n    self.cert_verify(conn, request.url, verify, cert)\n    url = self.request_url(request, proxies)\n    self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\n    chunked = not (request.body is None or 'Content-Length' in request.headers)\n    if isinstance(timeout, tuple):\n        try:\n            connect, read = timeout\n            timeout = TimeoutSauce(connect=connect, read=read)\n        except ValueError:\n            raise ValueError(f'Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, or a single float to set both timeouts to the same value.')\n    elif isinstance(timeout, TimeoutSauce):\n        pass\n    else:\n        timeout = TimeoutSauce(connect=timeout, read=timeout)\n    try:\n        resp = conn.urlopen(method=request.method, url=url, body=request.body, headers=request.headers, redirect=False, assert_same_host=False, preload_content=False, decode_content=False, retries=self.max_retries, timeout=timeout, chunked=chunked)\n    except (ProtocolError, OSError) as err:\n        raise ConnectionError(err, request=request)\n    except MaxRetryError as e:\n        if isinstance(e.reason, ConnectTimeoutError):\n            if not isinstance(e.reason, NewConnectionError):\n                raise ConnectTimeout(e, request=request)\n        if isinstance(e.reason, ResponseError):\n            raise RetryError(e, request=request)\n        if isinstance(e.reason, _ProxyError):\n            raise ProxyError(e, request=request)\n        if isinstance(e.reason, _SSLError):\n            raise SSLError(e, request=request)\n        raise ConnectionError(e, request=request)\n    except ClosedPoolError as e:\n        raise ConnectionError(e, request=request)\n    except _ProxyError as e:\n        raise ProxyError(e)\n    except (_SSLError, _HTTPError) as e:\n        if isinstance(e, _SSLError):\n            raise SSLError(e, request=request)\n        elif isinstance(e, ReadTimeoutError):\n            raise ReadTimeout(e, request=request)\n        elif isinstance(e, _InvalidHeader):\n            raise InvalidHeader(e, request=request)\n        else:\n            raise\n    return self.build_response(request, resp)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\api.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "request",
    "parameters": [
      "method",
      "url"
    ],
    "docstring_reference": "Constructs and sends a :class:`Request <Request>`.\n\n:param method: method for the new :class:`Request` object: ``GET``, ``OPTIONS``, ``HEAD``, ``POST``, ``PUT``, ``PATCH``, or ``DELETE``.\n:param url: URL for the new :class:`Request` object.\n:param params: (optional) Dictionary, list of tuples or bytes to send\n    in the query string for the :class:`Request`.\n:param data: (optional) Dictionary, list of tuples, bytes, or file-like\n    object to send in the body of the :class:`Request`.\n:param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n:param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n:param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n:param files: (optional) Dictionary of ``'name': file-like-objects`` (or ``{'name': file-tuple}``) for multipart encoding upload.\n    ``file-tuple`` can be a 2-tuple ``('filename', fileobj)``, 3-tuple ``('filename', fileobj, 'content_type')``\n    or a 4-tuple ``('filename', fileobj, 'content_type', custom_headers)``, where ``'content_type'`` is a string\n    defining the content type of the given file and ``custom_headers`` a dict-like object containing additional headers\n    to add for the file.\n:param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.\n:param timeout: (optional) How many seconds to wait for the server to send data\n    before giving up, as a float, or a :ref:`(connect timeout, read\n    timeout) <timeouts>` tuple.\n:type timeout: float or tuple\n:param allow_redirects: (optional) Boolean. Enable/disable GET/OPTIONS/POST/PUT/PATCH/DELETE/HEAD redirection. Defaults to ``True``.\n:type allow_redirects: bool\n:param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n:param verify: (optional) Either a boolean, in which case it controls whether we verify\n        the server's TLS certificate, or a string, in which case it must be a path\n        to a CA bundle to use. Defaults to ``True``.\n:param stream: (optional) if ``False``, the response content will be immediately downloaded.\n:param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.\n:return: :class:`Response <Response>` object\n:rtype: requests.Response\n\nUsage::\n\n  >>> import requests\n  >>> req = requests.request('GET', 'https://httpbin.org/get')\n  >>> req\n  <Response [200]>",
    "code_block": "def request(method, url, **kwargs):\n    \"\"\"Constructs and sends a :class:`Request <Request>`.\n\n    :param method: method for the new :class:`Request` object: ``GET``, ``OPTIONS``, ``HEAD``, ``POST``, ``PUT``, ``PATCH``, or ``DELETE``.\n    :param url: URL for the new :class:`Request` object.\n    :param params: (optional) Dictionary, list of tuples or bytes to send\n        in the query string for the :class:`Request`.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n    :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n    :param files: (optional) Dictionary of ``'name': file-like-objects`` (or ``{'name': file-tuple}``) for multipart encoding upload.\n        ``file-tuple`` can be a 2-tuple ``('filename', fileobj)``, 3-tuple ``('filename', fileobj, 'content_type')``\n        or a 4-tuple ``('filename', fileobj, 'content_type', custom_headers)``, where ``'content_type'`` is a string\n        defining the content type of the given file and ``custom_headers`` a dict-like object containing additional headers\n        to add for the file.\n    :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.\n    :param timeout: (optional) How many seconds to wait for the server to send data\n        before giving up, as a float, or a :ref:`(connect timeout, read\n        timeout) <timeouts>` tuple.\n    :type timeout: float or tuple\n    :param allow_redirects: (optional) Boolean. Enable/disable GET/OPTIONS/POST/PUT/PATCH/DELETE/HEAD redirection. Defaults to ``True``.\n    :type allow_redirects: bool\n    :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n    :param verify: (optional) Either a boolean, in which case it controls whether we verify\n            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use. Defaults to ``True``.\n    :param stream: (optional) if ``False``, the response content will be immediately downloaded.\n    :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n\n    Usage::\n\n      >>> import requests\n      >>> req = requests.request('GET', 'https://httpbin.org/get')\n      >>> req\n      <Response [200]>\n    \"\"\"\n    with sessions.Session() as session:\n        return session.request(method=method, url=url, **kwargs)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\api.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "get",
    "parameters": [
      "url",
      "params"
    ],
    "docstring_reference": "Sends a GET request.\n\n:param url: URL for the new :class:`Request` object.\n:param params: (optional) Dictionary, list of tuples or bytes to send\n    in the query string for the :class:`Request`.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:return: :class:`Response <Response>` object\n:rtype: requests.Response",
    "code_block": "def get(url, params=None, **kwargs):\n    \"\"\"Sends a GET request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param params: (optional) Dictionary, list of tuples or bytes to send\n        in the query string for the :class:`Request`.\n    :param \\\\*\\\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n    return request('get', url, params=params, **kwargs)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\api.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "options",
    "parameters": [
      "url"
    ],
    "docstring_reference": "Sends an OPTIONS request.\n\n:param url: URL for the new :class:`Request` object.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:return: :class:`Response <Response>` object\n:rtype: requests.Response",
    "code_block": "def options(url, **kwargs):\n    \"\"\"Sends an OPTIONS request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param \\\\*\\\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n    return request('options', url, **kwargs)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\api.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "head",
    "parameters": [
      "url"
    ],
    "docstring_reference": "Sends a HEAD request.\n\n:param url: URL for the new :class:`Request` object.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes. If\n    `allow_redirects` is not provided, it will be set to `False` (as\n    opposed to the default :meth:`request` behavior).\n:return: :class:`Response <Response>` object\n:rtype: requests.Response",
    "code_block": "def head(url, **kwargs):\n    \"\"\"Sends a HEAD request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param \\\\*\\\\*kwargs: Optional arguments that ``request`` takes. If\n        `allow_redirects` is not provided, it will be set to `False` (as\n        opposed to the default :meth:`request` behavior).\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n    kwargs.setdefault('allow_redirects', False)\n    return request('head', url, **kwargs)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\api.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "post",
    "parameters": [
      "url",
      "data",
      "json"
    ],
    "docstring_reference": "Sends a POST request.\n\n:param url: URL for the new :class:`Request` object.\n:param data: (optional) Dictionary, list of tuples, bytes, or file-like\n    object to send in the body of the :class:`Request`.\n:param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:return: :class:`Response <Response>` object\n:rtype: requests.Response",
    "code_block": "def post(url, data=None, json=None, **kwargs):\n    \"\"\"Sends a POST request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param \\\\*\\\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n    return request('post', url, data=data, json=json, **kwargs)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\api.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "put",
    "parameters": [
      "url",
      "data"
    ],
    "docstring_reference": "Sends a PUT request.\n\n:param url: URL for the new :class:`Request` object.\n:param data: (optional) Dictionary, list of tuples, bytes, or file-like\n    object to send in the body of the :class:`Request`.\n:param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:return: :class:`Response <Response>` object\n:rtype: requests.Response",
    "code_block": "def put(url, data=None, **kwargs):\n    \"\"\"Sends a PUT request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param \\\\*\\\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n    return request('put', url, data=data, **kwargs)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\api.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "patch",
    "parameters": [
      "url",
      "data"
    ],
    "docstring_reference": "Sends a PATCH request.\n\n:param url: URL for the new :class:`Request` object.\n:param data: (optional) Dictionary, list of tuples, bytes, or file-like\n    object to send in the body of the :class:`Request`.\n:param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:return: :class:`Response <Response>` object\n:rtype: requests.Response",
    "code_block": "def patch(url, data=None, **kwargs):\n    \"\"\"Sends a PATCH request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param data: (optional) Dictionary, list of tuples, bytes, or file-like\n        object to send in the body of the :class:`Request`.\n    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.\n    :param \\\\*\\\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n    return request('patch', url, data=data, **kwargs)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\api.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "delete",
    "parameters": [
      "url"
    ],
    "docstring_reference": "Sends a DELETE request.\n\n:param url: URL for the new :class:`Request` object.\n:param \\*\\*kwargs: Optional arguments that ``request`` takes.\n:return: :class:`Response <Response>` object\n:rtype: requests.Response",
    "code_block": "def delete(url, **kwargs):\n    \"\"\"Sends a DELETE request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param \\\\*\\\\*kwargs: Optional arguments that ``request`` takes.\n    :return: :class:`Response <Response>` object\n    :rtype: requests.Response\n    \"\"\"\n    return request('delete', url, **kwargs)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\structures.py",
    "code_entity_type": "ClassDef",
    "entity_name": "CaseInsensitiveDict",
    "parameters": [],
    "docstring_reference": "A case-insensitive ``dict``-like object.\n\nImplements all methods and operations of\n``MutableMapping`` as well as dict's ``copy``. Also\nprovides ``lower_items``.\n\nAll keys are expected to be strings. The structure remembers the\ncase of the last key to be set, and ``iter(instance)``,\n``keys()``, ``items()``, ``iterkeys()``, and ``iteritems()``\nwill contain case-sensitive keys. However, querying and contains\ntesting is case insensitive::\n\n    cid = CaseInsensitiveDict()\n    cid['Accept'] = 'application/json'\n    cid['aCCEPT'] == 'application/json'  # True\n    list(cid) == ['Accept']  # True\n\nFor example, ``headers['content-encoding']`` will return the\nvalue of a ``'Content-Encoding'`` response header, regardless\nof how the header name was originally stored.\n\nIf the constructor, ``.update``, or equality comparison\noperations are given keys that have equal ``.lower()``s, the\nbehavior is undefined.",
    "code_block": "class CaseInsensitiveDict(MutableMapping):\n    \"\"\"A case-insensitive ``dict``-like object.\n\n    Implements all methods and operations of\n    ``MutableMapping`` as well as dict's ``copy``. Also\n    provides ``lower_items``.\n\n    All keys are expected to be strings. The structure remembers the\n    case of the last key to be set, and ``iter(instance)``,\n    ``keys()``, ``items()``, ``iterkeys()``, and ``iteritems()``\n    will contain case-sensitive keys. However, querying and contains\n    testing is case insensitive::\n\n        cid = CaseInsensitiveDict()\n        cid['Accept'] = 'application/json'\n        cid['aCCEPT'] == 'application/json'  # True\n        list(cid) == ['Accept']  # True\n\n    For example, ``headers['content-encoding']`` will return the\n    value of a ``'Content-Encoding'`` response header, regardless\n    of how the header name was originally stored.\n\n    If the constructor, ``.update``, or equality comparison\n    operations are given keys that have equal ``.lower()``s, the\n    behavior is undefined.\n    \"\"\"\n\n    def __init__(self, data=None, **kwargs):\n        self._store = OrderedDict()\n        if data is None:\n            data = {}\n        self.update(data, **kwargs)\n\n    def __setitem__(self, key, value):\n        self._store[key.lower()] = (key, value)\n\n    def __getitem__(self, key):\n        return self._store[key.lower()][1]\n\n    def __delitem__(self, key):\n        del self._store[key.lower()]\n\n    def __iter__(self):\n        return (casedkey for casedkey, mappedvalue in self._store.values())\n\n    def __len__(self):\n        return len(self._store)\n\n    def lower_items(self):\n        \"\"\"Like iteritems(), but with all lowercase keys.\"\"\"\n        return ((lowerkey, keyval[1]) for lowerkey, keyval in self._store.items())\n\n    def __eq__(self, other):\n        if isinstance(other, Mapping):\n            other = CaseInsensitiveDict(other)\n        else:\n            return NotImplemented\n        return dict(self.lower_items()) == dict(other.lower_items())\n\n    def copy(self):\n        return CaseInsensitiveDict(self._store.values())\n\n    def __repr__(self):\n        return str(dict(self.items()))"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\structures.py",
    "code_entity_type": "ClassDef",
    "entity_name": "LookupDict",
    "parameters": [],
    "docstring_reference": "Dictionary lookup object.",
    "code_block": "class LookupDict(dict):\n    \"\"\"Dictionary lookup object.\"\"\"\n\n    def __init__(self, name=None):\n        self.name = name\n        super().__init__()\n\n    def __repr__(self):\n        return f\"<lookup '{self.name}'>\"\n\n    def __getitem__(self, key):\n        return self.__dict__.get(key, None)\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\structures.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "lower_items",
    "parameters": [
      "self"
    ],
    "docstring_reference": "Like iteritems(), but with all lowercase keys.",
    "code_block": "def lower_items(self):\n    \"\"\"Like iteritems(), but with all lowercase keys.\"\"\"\n    return ((lowerkey, keyval[1]) for lowerkey, keyval in self._store.items())"
  }
]