[
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "ClassDef",
    "entity_name": "MockRequest",
    "parameters": [],
    "docstring_reference": "Wraps a `requests.Request` to mimic a `urllib2.Request`.\n\nThe code in `http.cookiejar.CookieJar` expects this interface in order to correctly\nmanage cookie policies, i.e., determine whether a cookie can be set, given the\ndomains of the request and the cookie.\n\nThe original request object is read-only. The client is responsible for collecting\nthe new headers via `get_new_headers()` and interpreting them appropriately. You\nprobably want `get_cookie_header`, defined below.",
    "code_block": "class MockRequest:\n    \"\"\"Wraps a `requests.Request` to mimic a `urllib2.Request`.\n\n    The code in `http.cookiejar.CookieJar` expects this interface in order to correctly\n    manage cookie policies, i.e., determine whether a cookie can be set, given the\n    domains of the request and the cookie.\n\n    The original request object is read-only. The client is responsible for collecting\n    the new headers via `get_new_headers()` and interpreting them appropriately. You\n    probably want `get_cookie_header`, defined below.\n    \"\"\"\n\n    def __init__(self, request):\n        self._r = request\n        self._new_headers = {}\n        self.type = urlparse(self._r.url).scheme\n\n    def get_type(self):\n        return self.type\n\n    def get_host(self):\n        return urlparse(self._r.url).netloc\n\n    def get_origin_req_host(self):\n        return self.get_host()\n\n    def get_full_url(self):\n        if not self._r.headers.get('Host'):\n            return self._r.url\n        host = to_native_string(self._r.headers['Host'], encoding='utf-8')\n        parsed = urlparse(self._r.url)\n        return urlunparse([parsed.scheme, host, parsed.path, parsed.params, parsed.query, parsed.fragment])\n\n    def is_unverifiable(self):\n        return True\n\n    def has_header(self, name):\n        return name in self._r.headers or name in self._new_headers\n\n    def get_header(self, name, default=None):\n        return self._r.headers.get(name, self._new_headers.get(name, default))\n\n    def add_header(self, key, val):\n        \"\"\"cookiejar has no legitimate use for this method; add it back if you find one.\"\"\"\n        raise NotImplementedError('Cookie headers should be added with add_unredirected_header()')\n\n    def add_unredirected_header(self, name, value):\n        self._new_headers[name] = value\n\n    def get_new_headers(self):\n        return self._new_headers\n\n    @property\n    def unverifiable(self):\n        return self.is_unverifiable()\n\n    @property\n    def origin_req_host(self):\n        return self.get_origin_req_host()\n\n    @property\n    def host(self):\n        return self.get_host()"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "ClassDef",
    "entity_name": "MockResponse",
    "parameters": [],
    "docstring_reference": "Wraps a `httplib.HTTPMessage` to mimic a `urllib.addinfourl`.\n\n...what? Basically, expose the parsed HTTP headers from the server response\nthe way `http.cookiejar` expects to see them.",
    "code_block": "class MockResponse:\n    \"\"\"Wraps a `httplib.HTTPMessage` to mimic a `urllib.addinfourl`.\n\n    ...what? Basically, expose the parsed HTTP headers from the server response\n    the way `http.cookiejar` expects to see them.\n    \"\"\"\n\n    def __init__(self, headers):\n        \"\"\"Make a MockResponse for `cookiejar` to read.\n\n        :param headers: a httplib.HTTPMessage or analogous carrying the headers\n        \"\"\"\n        self._headers = headers\n\n    def info(self):\n        return self._headers\n\n    def getheaders(self, name):\n        self._headers.getheaders(name)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "extract_cookies_to_jar",
    "parameters": [
      "jar",
      "request",
      "response"
    ],
    "docstring_reference": "Extract the cookies from the response into a CookieJar.\n\n:param jar: http.cookiejar.CookieJar (not necessarily a RequestsCookieJar)\n:param request: our own requests.Request object\n:param response: urllib3.HTTPResponse object",
    "code_block": "def extract_cookies_to_jar(jar, request, response):\n    \"\"\"Extract the cookies from the response into a CookieJar.\n\n    :param jar: http.cookiejar.CookieJar (not necessarily a RequestsCookieJar)\n    :param request: our own requests.Request object\n    :param response: urllib3.HTTPResponse object\n    \"\"\"\n    if not (hasattr(response, '_original_response') and response._original_response):\n        return\n    req = MockRequest(request)\n    res = MockResponse(response._original_response.msg)\n    jar.extract_cookies(res, req)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "get_cookie_header",
    "parameters": [
      "jar",
      "request"
    ],
    "docstring_reference": "Produce an appropriate Cookie header string to be sent with `request`, or None.\n\n:rtype: str",
    "code_block": "def get_cookie_header(jar, request):\n    \"\"\"\n    Produce an appropriate Cookie header string to be sent with `request`, or None.\n\n    :rtype: str\n    \"\"\"\n    r = MockRequest(request)\n    jar.add_cookie_header(r)\n    return r.get_new_headers().get('Cookie')"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "remove_cookie_by_name",
    "parameters": [
      "cookiejar",
      "name",
      "domain",
      "path"
    ],
    "docstring_reference": "Unsets a cookie by name, by default over all domains and paths.\n\nWraps CookieJar.clear(), is O(n).",
    "code_block": "def remove_cookie_by_name(cookiejar, name, domain=None, path=None):\n    \"\"\"Unsets a cookie by name, by default over all domains and paths.\n\n    Wraps CookieJar.clear(), is O(n).\n    \"\"\"\n    clearables = []\n    for cookie in cookiejar:\n        if cookie.name != name:\n            continue\n        if domain is not None and domain != cookie.domain:\n            continue\n        if path is not None and path != cookie.path:\n            continue\n        clearables.append((cookie.domain, cookie.path, cookie.name))\n    for domain, path, name in clearables:\n        cookiejar.clear(domain, path, name)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "ClassDef",
    "entity_name": "CookieConflictError",
    "parameters": [],
    "docstring_reference": "There are two cookies that meet the criteria specified in the cookie jar.\nUse .get and .set and include domain and path args in order to be more specific.",
    "code_block": "class CookieConflictError(RuntimeError):\n    \"\"\"There are two cookies that meet the criteria specified in the cookie jar.\n    Use .get and .set and include domain and path args in order to be more specific.\n    \"\"\""
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "ClassDef",
    "entity_name": "RequestsCookieJar",
    "parameters": [],
    "docstring_reference": "Compatibility class; is a http.cookiejar.CookieJar, but exposes a dict\ninterface.\n\nThis is the CookieJar we create by default for requests and sessions that\ndon't specify one, since some clients may expect response.cookies and\nsession.cookies to support dict operations.\n\nRequests does not use the dict interface internally; it's just for\ncompatibility with external client code. All requests code should work\nout of the box with externally provided instances of ``CookieJar``, e.g.\n``LWPCookieJar`` and ``FileCookieJar``.\n\nUnlike a regular CookieJar, this class is pickleable.\n\n.. warning:: dictionary operations that are normally O(1) may be O(n).",
    "code_block": "class RequestsCookieJar(cookielib.CookieJar, MutableMapping):\n    \"\"\"Compatibility class; is a http.cookiejar.CookieJar, but exposes a dict\n    interface.\n\n    This is the CookieJar we create by default for requests and sessions that\n    don't specify one, since some clients may expect response.cookies and\n    session.cookies to support dict operations.\n\n    Requests does not use the dict interface internally; it's just for\n    compatibility with external client code. All requests code should work\n    out of the box with externally provided instances of ``CookieJar``, e.g.\n    ``LWPCookieJar`` and ``FileCookieJar``.\n\n    Unlike a regular CookieJar, this class is pickleable.\n\n    .. warning:: dictionary operations that are normally O(1) may be O(n).\n    \"\"\"\n\n    def get(self, name, default=None, domain=None, path=None):\n        \"\"\"Dict-like get() that also supports optional domain and path args in\n        order to resolve naming collisions from using one cookie jar over\n        multiple domains.\n\n        .. warning:: operation is O(n), not O(1).\n        \"\"\"\n        try:\n            return self._find_no_duplicates(name, domain, path)\n        except KeyError:\n            return default\n\n    def set(self, name, value, **kwargs):\n        \"\"\"Dict-like set() that also supports optional domain and path args in\n        order to resolve naming collisions from using one cookie jar over\n        multiple domains.\n        \"\"\"\n        if value is None:\n            remove_cookie_by_name(self, name, domain=kwargs.get('domain'), path=kwargs.get('path'))\n            return\n        if isinstance(value, Morsel):\n            c = morsel_to_cookie(value)\n        else:\n            c = create_cookie(name, value, **kwargs)\n        self.set_cookie(c)\n        return c\n\n    def iterkeys(self):\n        \"\"\"Dict-like iterkeys() that returns an iterator of names of cookies\n        from the jar.\n\n        .. seealso:: itervalues() and iteritems().\n        \"\"\"\n        for cookie in iter(self):\n            yield cookie.name\n\n    def keys(self):\n        \"\"\"Dict-like keys() that returns a list of names of cookies from the\n        jar.\n\n        .. seealso:: values() and items().\n        \"\"\"\n        return list(self.iterkeys())\n\n    def itervalues(self):\n        \"\"\"Dict-like itervalues() that returns an iterator of values of cookies\n        from the jar.\n\n        .. seealso:: iterkeys() and iteritems().\n        \"\"\"\n        for cookie in iter(self):\n            yield cookie.value\n\n    def values(self):\n        \"\"\"Dict-like values() that returns a list of values of cookies from the\n        jar.\n\n        .. seealso:: keys() and items().\n        \"\"\"\n        return list(self.itervalues())\n\n    def iteritems(self):\n        \"\"\"Dict-like iteritems() that returns an iterator of name-value tuples\n        from the jar.\n\n        .. seealso:: iterkeys() and itervalues().\n        \"\"\"\n        for cookie in iter(self):\n            yield (cookie.name, cookie.value)\n\n    def items(self):\n        \"\"\"Dict-like items() that returns a list of name-value tuples from the\n        jar. Allows client-code to call ``dict(RequestsCookieJar)`` and get a\n        vanilla python dict of key value pairs.\n\n        .. seealso:: keys() and values().\n        \"\"\"\n        return list(self.iteritems())\n\n    def list_domains(self):\n        \"\"\"Utility method to list all the domains in the jar.\"\"\"\n        domains = []\n        for cookie in iter(self):\n            if cookie.domain not in domains:\n                domains.append(cookie.domain)\n        return domains\n\n    def list_paths(self):\n        \"\"\"Utility method to list all the paths in the jar.\"\"\"\n        paths = []\n        for cookie in iter(self):\n            if cookie.path not in paths:\n                paths.append(cookie.path)\n        return paths\n\n    def multiple_domains(self):\n        \"\"\"Returns True if there are multiple domains in the jar.\n        Returns False otherwise.\n\n        :rtype: bool\n        \"\"\"\n        domains = []\n        for cookie in iter(self):\n            if cookie.domain is not None and cookie.domain in domains:\n                return True\n            domains.append(cookie.domain)\n        return False\n\n    def get_dict(self, domain=None, path=None):\n        \"\"\"Takes as an argument an optional domain and path and returns a plain\n        old Python dict of name-value pairs of cookies that meet the\n        requirements.\n\n        :rtype: dict\n        \"\"\"\n        dictionary = {}\n        for cookie in iter(self):\n            if (domain is None or cookie.domain == domain) and (path is None or cookie.path == path):\n                dictionary[cookie.name] = cookie.value\n        return dictionary\n\n    def __contains__(self, name):\n        try:\n            return super().__contains__(name)\n        except CookieConflictError:\n            return True\n\n    def __getitem__(self, name):\n        \"\"\"Dict-like __getitem__() for compatibility with client code. Throws\n        exception if there are more than one cookie with name. In that case,\n        use the more explicit get() method instead.\n\n        .. warning:: operation is O(n), not O(1).\n        \"\"\"\n        return self._find_no_duplicates(name)\n\n    def __setitem__(self, name, value):\n        \"\"\"Dict-like __setitem__ for compatibility with client code. Throws\n        exception if there is already a cookie of that name in the jar. In that\n        case, use the more explicit set() method instead.\n        \"\"\"\n        self.set(name, value)\n\n    def __delitem__(self, name):\n        \"\"\"Deletes a cookie given a name. Wraps ``http.cookiejar.CookieJar``'s\n        ``remove_cookie_by_name()``.\n        \"\"\"\n        remove_cookie_by_name(self, name)\n\n    def set_cookie(self, cookie, *args, **kwargs):\n        if hasattr(cookie.value, 'startswith') and cookie.value.startswith('\"') and cookie.value.endswith('\"'):\n            cookie.value = cookie.value.replace('\\\\\"', '')\n        return super().set_cookie(cookie, *args, **kwargs)\n\n    def update(self, other):\n        \"\"\"Updates this jar with cookies from another CookieJar or dict-like\"\"\"\n        if isinstance(other, cookielib.CookieJar):\n            for cookie in other:\n                self.set_cookie(copy.copy(cookie))\n        else:\n            super().update(other)\n\n    def _find(self, name, domain=None, path=None):\n        \"\"\"Requests uses this method internally to get cookie values.\n\n        If there are conflicting cookies, _find arbitrarily chooses one.\n        See _find_no_duplicates if you want an exception thrown if there are\n        conflicting cookies.\n\n        :param name: a string containing name of cookie\n        :param domain: (optional) string containing domain of cookie\n        :param path: (optional) string containing path of cookie\n        :return: cookie.value\n        \"\"\"\n        for cookie in iter(self):\n            if cookie.name == name:\n                if domain is None or cookie.domain == domain:\n                    if path is None or cookie.path == path:\n                        return cookie.value\n        raise KeyError(f'name={name!r}, domain={domain!r}, path={path!r}')\n\n    def _find_no_duplicates(self, name, domain=None, path=None):\n        \"\"\"Both ``__get_item__`` and ``get`` call this function: it's never\n        used elsewhere in Requests.\n\n        :param name: a string containing name of cookie\n        :param domain: (optional) string containing domain of cookie\n        :param path: (optional) string containing path of cookie\n        :raises KeyError: if cookie is not found\n        :raises CookieConflictError: if there are multiple cookies\n            that match name and optionally domain and path\n        :return: cookie.value\n        \"\"\"\n        toReturn = None\n        for cookie in iter(self):\n            if cookie.name == name:\n                if domain is None or cookie.domain == domain:\n                    if path is None or cookie.path == path:\n                        if toReturn is not None:\n                            raise CookieConflictError(f'There are multiple cookies with name, {name!r}')\n                        toReturn = cookie.value\n        if toReturn:\n            return toReturn\n        raise KeyError(f'name={name!r}, domain={domain!r}, path={path!r}')\n\n    def __getstate__(self):\n        \"\"\"Unlike a normal CookieJar, this class is pickleable.\"\"\"\n        state = self.__dict__.copy()\n        state.pop('_cookies_lock')\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Unlike a normal CookieJar, this class is pickleable.\"\"\"\n        self.__dict__.update(state)\n        if '_cookies_lock' not in self.__dict__:\n            self._cookies_lock = threading.RLock()\n\n    def copy(self):\n        \"\"\"Return a copy of this RequestsCookieJar.\"\"\"\n        new_cj = RequestsCookieJar()\n        new_cj.set_policy(self.get_policy())\n        new_cj.update(self)\n        return new_cj\n\n    def get_policy(self):\n        \"\"\"Return the CookiePolicy instance used.\"\"\"\n        return self._policy"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "create_cookie",
    "parameters": [
      "name",
      "value"
    ],
    "docstring_reference": "Make a cookie from underspecified parameters.\n\nBy default, the pair of `name` and `value` will be set for the domain ''\nand sent on every request (this is sometimes called a \"supercookie\").",
    "code_block": "def create_cookie(name, value, **kwargs):\n    \"\"\"Make a cookie from underspecified parameters.\n\n    By default, the pair of `name` and `value` will be set for the domain ''\n    and sent on every request (this is sometimes called a \"supercookie\").\n    \"\"\"\n    result = {'version': 0, 'name': name, 'value': value, 'port': None, 'domain': '', 'path': '/', 'secure': False, 'expires': None, 'discard': True, 'comment': None, 'comment_url': None, 'rest': {'HttpOnly': None}, 'rfc2109': False}\n    badargs = set(kwargs) - set(result)\n    if badargs:\n        raise TypeError(f'create_cookie() got unexpected keyword arguments: {list(badargs)}')\n    result.update(kwargs)\n    result['port_specified'] = bool(result['port'])\n    result['domain_specified'] = bool(result['domain'])\n    result['domain_initial_dot'] = result['domain'].startswith('.')\n    result['path_specified'] = bool(result['path'])\n    return cookielib.Cookie(**result)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "morsel_to_cookie",
    "parameters": [
      "morsel"
    ],
    "docstring_reference": "Convert a Morsel object into a Cookie containing the one k/v pair.",
    "code_block": "def morsel_to_cookie(morsel):\n    \"\"\"Convert a Morsel object into a Cookie containing the one k/v pair.\"\"\"\n    expires = None\n    if morsel['max-age']:\n        try:\n            expires = int(time.time() + int(morsel['max-age']))\n        except ValueError:\n            raise TypeError(f\"max-age: {morsel['max-age']} must be integer\")\n    elif morsel['expires']:\n        time_template = '%a, %d-%b-%Y %H:%M:%S GMT'\n        expires = calendar.timegm(time.strptime(morsel['expires'], time_template))\n    return create_cookie(comment=morsel['comment'], comment_url=bool(morsel['comment']), discard=False, domain=morsel['domain'], expires=expires, name=morsel.key, path=morsel['path'], port=None, rest={'HttpOnly': morsel['httponly']}, rfc2109=False, secure=bool(morsel['secure']), value=morsel.value, version=morsel['version'] or 0)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "cookiejar_from_dict",
    "parameters": [
      "cookie_dict",
      "cookiejar",
      "overwrite"
    ],
    "docstring_reference": "Returns a CookieJar from a key/value dictionary.\n\n:param cookie_dict: Dict of key/values to insert into CookieJar.\n:param cookiejar: (optional) A cookiejar to add the cookies to.\n:param overwrite: (optional) If False, will not replace cookies\n    already in the jar with new ones.\n:rtype: CookieJar",
    "code_block": "def cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True):\n    \"\"\"Returns a CookieJar from a key/value dictionary.\n\n    :param cookie_dict: Dict of key/values to insert into CookieJar.\n    :param cookiejar: (optional) A cookiejar to add the cookies to.\n    :param overwrite: (optional) If False, will not replace cookies\n        already in the jar with new ones.\n    :rtype: CookieJar\n    \"\"\"\n    if cookiejar is None:\n        cookiejar = RequestsCookieJar()\n    if cookie_dict is not None:\n        names_from_jar = [cookie.name for cookie in cookiejar]\n        for name in cookie_dict:\n            if overwrite or name not in names_from_jar:\n                cookiejar.set_cookie(create_cookie(name, cookie_dict[name]))\n    return cookiejar"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "merge_cookies",
    "parameters": [
      "cookiejar",
      "cookies"
    ],
    "docstring_reference": "Add cookies to cookiejar and returns a merged CookieJar.\n\n:param cookiejar: CookieJar object to add the cookies to.\n:param cookies: Dictionary or CookieJar object to be added.\n:rtype: CookieJar",
    "code_block": "def merge_cookies(cookiejar, cookies):\n    \"\"\"Add cookies to cookiejar and returns a merged CookieJar.\n\n    :param cookiejar: CookieJar object to add the cookies to.\n    :param cookies: Dictionary or CookieJar object to be added.\n    :rtype: CookieJar\n    \"\"\"\n    if not isinstance(cookiejar, cookielib.CookieJar):\n        raise ValueError('You can only merge into CookieJar')\n    if isinstance(cookies, dict):\n        cookiejar = cookiejar_from_dict(cookies, cookiejar=cookiejar, overwrite=False)\n    elif isinstance(cookies, cookielib.CookieJar):\n        try:\n            cookiejar.update(cookies)\n        except AttributeError:\n            for cookie_in_jar in cookies:\n                cookiejar.set_cookie(cookie_in_jar)\n    return cookiejar"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "add_header",
    "parameters": [
      "self",
      "key",
      "val"
    ],
    "docstring_reference": "cookiejar has no legitimate use for this method; add it back if you find one.",
    "code_block": "def add_header(self, key, val):\n    \"\"\"cookiejar has no legitimate use for this method; add it back if you find one.\"\"\"\n    raise NotImplementedError('Cookie headers should be added with add_unredirected_header()')"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "__init__",
    "parameters": [
      "self",
      "headers"
    ],
    "docstring_reference": "Make a MockResponse for `cookiejar` to read.\n\n:param headers: a httplib.HTTPMessage or analogous carrying the headers",
    "code_block": "def __init__(self, headers):\n    \"\"\"Make a MockResponse for `cookiejar` to read.\n\n        :param headers: a httplib.HTTPMessage or analogous carrying the headers\n        \"\"\"\n    self._headers = headers"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "get",
    "parameters": [
      "self",
      "name",
      "default",
      "domain",
      "path"
    ],
    "docstring_reference": "Dict-like get() that also supports optional domain and path args in\norder to resolve naming collisions from using one cookie jar over\nmultiple domains.\n\n.. warning:: operation is O(n), not O(1).",
    "code_block": "def get(self, name, default=None, domain=None, path=None):\n    \"\"\"Dict-like get() that also supports optional domain and path args in\n        order to resolve naming collisions from using one cookie jar over\n        multiple domains.\n\n        .. warning:: operation is O(n), not O(1).\n        \"\"\"\n    try:\n        return self._find_no_duplicates(name, domain, path)\n    except KeyError:\n        return default"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "set",
    "parameters": [
      "self",
      "name",
      "value"
    ],
    "docstring_reference": "Dict-like set() that also supports optional domain and path args in\norder to resolve naming collisions from using one cookie jar over\nmultiple domains.",
    "code_block": "def set(self, name, value, **kwargs):\n    \"\"\"Dict-like set() that also supports optional domain and path args in\n        order to resolve naming collisions from using one cookie jar over\n        multiple domains.\n        \"\"\"\n    if value is None:\n        remove_cookie_by_name(self, name, domain=kwargs.get('domain'), path=kwargs.get('path'))\n        return\n    if isinstance(value, Morsel):\n        c = morsel_to_cookie(value)\n    else:\n        c = create_cookie(name, value, **kwargs)\n    self.set_cookie(c)\n    return c"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "iterkeys",
    "parameters": [
      "self"
    ],
    "docstring_reference": "Dict-like iterkeys() that returns an iterator of names of cookies\nfrom the jar.\n\n.. seealso:: itervalues() and iteritems().",
    "code_block": "def iterkeys(self):\n    \"\"\"Dict-like iterkeys() that returns an iterator of names of cookies\n        from the jar.\n\n        .. seealso:: itervalues() and iteritems().\n        \"\"\"\n    for cookie in iter(self):\n        yield cookie.name"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "keys",
    "parameters": [
      "self"
    ],
    "docstring_reference": "Dict-like keys() that returns a list of names of cookies from the\njar.\n\n.. seealso:: values() and items().",
    "code_block": "def keys(self):\n    \"\"\"Dict-like keys() that returns a list of names of cookies from the\n        jar.\n\n        .. seealso:: values() and items().\n        \"\"\"\n    return list(self.iterkeys())"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "itervalues",
    "parameters": [
      "self"
    ],
    "docstring_reference": "Dict-like itervalues() that returns an iterator of values of cookies\nfrom the jar.\n\n.. seealso:: iterkeys() and iteritems().",
    "code_block": "def itervalues(self):\n    \"\"\"Dict-like itervalues() that returns an iterator of values of cookies\n        from the jar.\n\n        .. seealso:: iterkeys() and iteritems().\n        \"\"\"\n    for cookie in iter(self):\n        yield cookie.value"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "values",
    "parameters": [
      "self"
    ],
    "docstring_reference": "Dict-like values() that returns a list of values of cookies from the\njar.\n\n.. seealso:: keys() and items().",
    "code_block": "def values(self):\n    \"\"\"Dict-like values() that returns a list of values of cookies from the\n        jar.\n\n        .. seealso:: keys() and items().\n        \"\"\"\n    return list(self.itervalues())"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "iteritems",
    "parameters": [
      "self"
    ],
    "docstring_reference": "Dict-like iteritems() that returns an iterator of name-value tuples\nfrom the jar.\n\n.. seealso:: iterkeys() and itervalues().",
    "code_block": "def iteritems(self):\n    \"\"\"Dict-like iteritems() that returns an iterator of name-value tuples\n        from the jar.\n\n        .. seealso:: iterkeys() and itervalues().\n        \"\"\"\n    for cookie in iter(self):\n        yield (cookie.name, cookie.value)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "items",
    "parameters": [
      "self"
    ],
    "docstring_reference": "Dict-like items() that returns a list of name-value tuples from the\njar. Allows client-code to call ``dict(RequestsCookieJar)`` and get a\nvanilla python dict of key value pairs.\n\n.. seealso:: keys() and values().",
    "code_block": "def items(self):\n    \"\"\"Dict-like items() that returns a list of name-value tuples from the\n        jar. Allows client-code to call ``dict(RequestsCookieJar)`` and get a\n        vanilla python dict of key value pairs.\n\n        .. seealso:: keys() and values().\n        \"\"\"\n    return list(self.iteritems())"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "list_domains",
    "parameters": [
      "self"
    ],
    "docstring_reference": "Utility method to list all the domains in the jar.",
    "code_block": "def list_domains(self):\n    \"\"\"Utility method to list all the domains in the jar.\"\"\"\n    domains = []\n    for cookie in iter(self):\n        if cookie.domain not in domains:\n            domains.append(cookie.domain)\n    return domains"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "list_paths",
    "parameters": [
      "self"
    ],
    "docstring_reference": "Utility method to list all the paths in the jar.",
    "code_block": "def list_paths(self):\n    \"\"\"Utility method to list all the paths in the jar.\"\"\"\n    paths = []\n    for cookie in iter(self):\n        if cookie.path not in paths:\n            paths.append(cookie.path)\n    return paths"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "multiple_domains",
    "parameters": [
      "self"
    ],
    "docstring_reference": "Returns True if there are multiple domains in the jar.\nReturns False otherwise.\n\n:rtype: bool",
    "code_block": "def multiple_domains(self):\n    \"\"\"Returns True if there are multiple domains in the jar.\n        Returns False otherwise.\n\n        :rtype: bool\n        \"\"\"\n    domains = []\n    for cookie in iter(self):\n        if cookie.domain is not None and cookie.domain in domains:\n            return True\n        domains.append(cookie.domain)\n    return False"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "get_dict",
    "parameters": [
      "self",
      "domain",
      "path"
    ],
    "docstring_reference": "Takes as an argument an optional domain and path and returns a plain\nold Python dict of name-value pairs of cookies that meet the\nrequirements.\n\n:rtype: dict",
    "code_block": "def get_dict(self, domain=None, path=None):\n    \"\"\"Takes as an argument an optional domain and path and returns a plain\n        old Python dict of name-value pairs of cookies that meet the\n        requirements.\n\n        :rtype: dict\n        \"\"\"\n    dictionary = {}\n    for cookie in iter(self):\n        if (domain is None or cookie.domain == domain) and (path is None or cookie.path == path):\n            dictionary[cookie.name] = cookie.value\n    return dictionary"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "__getitem__",
    "parameters": [
      "self",
      "name"
    ],
    "docstring_reference": "Dict-like __getitem__() for compatibility with client code. Throws\nexception if there are more than one cookie with name. In that case,\nuse the more explicit get() method instead.\n\n.. warning:: operation is O(n), not O(1).",
    "code_block": "def __getitem__(self, name):\n    \"\"\"Dict-like __getitem__() for compatibility with client code. Throws\n        exception if there are more than one cookie with name. In that case,\n        use the more explicit get() method instead.\n\n        .. warning:: operation is O(n), not O(1).\n        \"\"\"\n    return self._find_no_duplicates(name)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "__setitem__",
    "parameters": [
      "self",
      "name",
      "value"
    ],
    "docstring_reference": "Dict-like __setitem__ for compatibility with client code. Throws\nexception if there is already a cookie of that name in the jar. In that\ncase, use the more explicit set() method instead.",
    "code_block": "def __setitem__(self, name, value):\n    \"\"\"Dict-like __setitem__ for compatibility with client code. Throws\n        exception if there is already a cookie of that name in the jar. In that\n        case, use the more explicit set() method instead.\n        \"\"\"\n    self.set(name, value)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "__delitem__",
    "parameters": [
      "self",
      "name"
    ],
    "docstring_reference": "Deletes a cookie given a name. Wraps ``http.cookiejar.CookieJar``'s\n``remove_cookie_by_name()``.",
    "code_block": "def __delitem__(self, name):\n    \"\"\"Deletes a cookie given a name. Wraps ``http.cookiejar.CookieJar``'s\n        ``remove_cookie_by_name()``.\n        \"\"\"\n    remove_cookie_by_name(self, name)"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "_find",
    "parameters": [
      "self",
      "name",
      "domain",
      "path"
    ],
    "docstring_reference": "Requests uses this method internally to get cookie values.\n\nIf there are conflicting cookies, _find arbitrarily chooses one.\nSee _find_no_duplicates if you want an exception thrown if there are\nconflicting cookies.\n\n:param name: a string containing name of cookie\n:param domain: (optional) string containing domain of cookie\n:param path: (optional) string containing path of cookie\n:return: cookie.value",
    "code_block": "def _find(self, name, domain=None, path=None):\n    \"\"\"Requests uses this method internally to get cookie values.\n\n        If there are conflicting cookies, _find arbitrarily chooses one.\n        See _find_no_duplicates if you want an exception thrown if there are\n        conflicting cookies.\n\n        :param name: a string containing name of cookie\n        :param domain: (optional) string containing domain of cookie\n        :param path: (optional) string containing path of cookie\n        :return: cookie.value\n        \"\"\"\n    for cookie in iter(self):\n        if cookie.name == name:\n            if domain is None or cookie.domain == domain:\n                if path is None or cookie.path == path:\n                    return cookie.value\n    raise KeyError(f'name={name!r}, domain={domain!r}, path={path!r}')"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "_find_no_duplicates",
    "parameters": [
      "self",
      "name",
      "domain",
      "path"
    ],
    "docstring_reference": "Both ``__get_item__`` and ``get`` call this function: it's never\nused elsewhere in Requests.\n\n:param name: a string containing name of cookie\n:param domain: (optional) string containing domain of cookie\n:param path: (optional) string containing path of cookie\n:raises KeyError: if cookie is not found\n:raises CookieConflictError: if there are multiple cookies\n    that match name and optionally domain and path\n:return: cookie.value",
    "code_block": "def _find_no_duplicates(self, name, domain=None, path=None):\n    \"\"\"Both ``__get_item__`` and ``get`` call this function: it's never\n        used elsewhere in Requests.\n\n        :param name: a string containing name of cookie\n        :param domain: (optional) string containing domain of cookie\n        :param path: (optional) string containing path of cookie\n        :raises KeyError: if cookie is not found\n        :raises CookieConflictError: if there are multiple cookies\n            that match name and optionally domain and path\n        :return: cookie.value\n        \"\"\"\n    toReturn = None\n    for cookie in iter(self):\n        if cookie.name == name:\n            if domain is None or cookie.domain == domain:\n                if path is None or cookie.path == path:\n                    if toReturn is not None:\n                        raise CookieConflictError(f'There are multiple cookies with name, {name!r}')\n                    toReturn = cookie.value\n    if toReturn:\n        return toReturn\n    raise KeyError(f'name={name!r}, domain={domain!r}, path={path!r}')"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "__getstate__",
    "parameters": [
      "self"
    ],
    "docstring_reference": "Unlike a normal CookieJar, this class is pickleable.",
    "code_block": "def __getstate__(self):\n    \"\"\"Unlike a normal CookieJar, this class is pickleable.\"\"\"\n    state = self.__dict__.copy()\n    state.pop('_cookies_lock')\n    return state"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "__setstate__",
    "parameters": [
      "self",
      "state"
    ],
    "docstring_reference": "Unlike a normal CookieJar, this class is pickleable.",
    "code_block": "def __setstate__(self, state):\n    \"\"\"Unlike a normal CookieJar, this class is pickleable.\"\"\"\n    self.__dict__.update(state)\n    if '_cookies_lock' not in self.__dict__:\n        self._cookies_lock = threading.RLock()"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "copy",
    "parameters": [
      "self"
    ],
    "docstring_reference": "Return a copy of this RequestsCookieJar.",
    "code_block": "def copy(self):\n    \"\"\"Return a copy of this RequestsCookieJar.\"\"\"\n    new_cj = RequestsCookieJar()\n    new_cj.set_policy(self.get_policy())\n    new_cj.update(self)\n    return new_cj"
  },
  {
    "file_path": "C:\\Users\\ankus\\ai-doc-writer\\data\\raw\\requests\\src\\requests\\cookies.py",
    "code_entity_type": "FunctionDef",
    "entity_name": "get_policy",
    "parameters": [
      "self"
    ],
    "docstring_reference": "Return the CookiePolicy instance used.",
    "code_block": "def get_policy(self):\n    \"\"\"Return the CookiePolicy instance used.\"\"\"\n    return self._policy"
  }
]